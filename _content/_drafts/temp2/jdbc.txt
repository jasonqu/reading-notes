jdbc

http://www.oracle.com/technetwork/java/overview-141217.html

The JDBC API provides a call-level API for SQL-based database access.

#### JDBC API Overview

The JDBC API makes it possible to do three things:

* Establish a connection with a database or access any tabular data source
* Send SQL statements
* Process the results

#### JDBC Architecture

Type 4: Direct-to-Database Pure Java Driver
This style of driver converts JDBC calls into the network protocol used directly by DBMSs, allowing a direct call from the client machine to the DBMS server and providing a practical solution for intranet access.

#### Key Features

* Full Access to Metadata
* No Installation
* Database Connection Identified by URL
  JDBC technology exploits the advantages of Internet-standard URLs to identify database connections. The JDBC API includes an even better way to identify and connect to a data source, using a DataSource object, that makes code even more portable and easier to maintain.
  In addition to this important advantage, DataSource objects can provide connection pooling and distributed transactions, essential for enterprise database computing. This functionality is provided transparently to the programmer.






http://dev.mysql.com/doc/connector-j/en/index.html

#### Chapter 2 Connector/J Versions

Connector/J 5.1 provides ease of development features, including auto-registration with the Driver Manager, standardized validity checks, categorized SQLExceptions, support for the JDBC-4.0 XML processing, per connection client information, NCHAR, NVARCHAR and NCLOB types.


http://dev.mysql.com/doc/connector-j/en/connector-j-examples.html

indexes 例子在后面

http://dev.mysql.com/doc/connector-j/en/connector-j-reference.html

5.1 Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J

This now allows per-host overrides of any configuration property for multi-host connections (that is, when using failover, load balancing, or replication). Limit the overrides to user, password, network timeouts and statement and metadata cache sizes; the results of other per-host overrides are not defined.

参数列表
http://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html


5.2 JDBC API Implementation Notes

* Connection

Unlike the pre-Connector/J JDBC driver (MM.MySQL), the isClosed() method does not ping the server to determine if it is available. In accordance with the JDBC specification, it only returns true if closed() has been called on the connection. If you need to determine if the connection is still valid, issue a simple query, such as SELECT 1. The driver will throw an exception if the connection is no longer valid.

* PreparedStatement

PreparedStatements are implemented by the driver, as MySQL does not have a prepared statement feature. Because of this, the driver does not implement getParameterMetaData() or getMetaData() as it would require the driver to have a complete SQL parser in the client.

* ResultSet

By default, ResultSets are completely retrieved and stored in memory. In most cases this is the most efficient way to operate, and due to the design of the MySQL network protocol is easier to implement. If you are working with ResultSets that have a large number of rows or large values, and cannot allocate heap space in your JVM for the memory required, you can tell the driver to stream the results back one row at a time.

To enable this functionality, create a Statement instance in the following manner:

```
stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY,
              java.sql.ResultSet.CONCUR_READ_ONLY);
stmt.setFetchSize(Integer.MIN_VALUE);
```

5.3 Java, JDBC and MySQL Types

The conversions that are always guaranteed to work are listed in the following table.
略

The ResultSet.getObject() method uses the type conversions between MySQL and Java types, following the JDBC specification where appropriate. The value returned by ResultSetMetaData.GetColumnClassName() is also shown below.
略

5.4 Using Character Sets and Unicode

All strings sent from the JDBC driver to the server are converted automatically from native Java Unicode form to the client character encoding,


Chapter 6 JDBC Concepts

6.1 Connecting to MySQL Using the JDBC DriverManager Interface

When you are using JDBC outside of an application server, the DriverManager class manages the establishment of connections.

DriverManager负责创建连接




6.4 Retrieving AUTO_INCREMENT Column Values through JDBC

At times, it can be tricky to use the SELECT LAST_INSERT_ID() query, as that function's value is scoped to a connection. So, if some other query happens on the same connection, the value is overwritten. On the other hand, the getGeneratedKeys() method is scoped by the Statement instance, so it can be used even if other queries happen on the same connection, but not on the same Statement instance.



Chapter 7 Connection Pooling with Connector/J

连接池

#### How Connection Pooling Works

Most applications only need a thread to have access to a JDBC connection when they are actively processing a transaction, which often takes only milliseconds to complete. When not processing a transaction, the connection sits idle. Connection pooling enables the idle connection to be used by some other thread to do useful work.
大多数应用只在处理事务时才使用一个jdbc连接，一般只需要几个毫秒，其他时间就是空闲。连接池允许该连接被其他线程使用，提高效率

简单讲，就是从pool中拿，用完，放回pool中

#### Benefits of Connection Pooling

* Reduced connection creation time. 减少连接创建时间
* Simplified programming model.
* Controlled resource usage.
  If you create a new connection every time a thread needs one, rather than using connection pooling, your application's resource usage can be wasteful and lead to unpredictable behavior under load.

Example 7.1 Connector/J: Using a connection pool with a J2EE application server

```
InitialContext ctx = new InitialContext();
DataSource ds =
          (DataSource)ctx.lookup("java:comp/env/jdbc/MySQLDB");
conn = ds.getConnection();

            /*
             * Now, use normal JDBC programming to work with
             * MySQL, making sure to close each resource when you're
             * finished with it, which permits the connection pool
             * resources to be recovered as quickly as possible
             */

            stmt = conn.createStatement();
            stmt.execute("SOME SQL QUERY");

            stmt.close();
            stmt = null;

            conn.close();
            conn = null;

```

When these objects are closed, they can be re-used; otherwise, they will be stranded, which means that the MySQL server resources they represent (such as buffers, locks, or sockets) are tied up for some time, or in the worst case can be tied up forever.

#### Sizing the Connection Pool

Many of these resources will be used whether or not the connection is actually doing any useful work! Connection pools can be tuned to maximize performance, while keeping resource utilization below the point where your application will start to fail rather than just run slower.
每个连接都有资源，只要创建，就要占用资源。如果不够，应用会失败而不是缓慢


#### Validating Connections

MySQL Connector/J can validate the connection by executing a lightweight ping against a server. In the case of load-balanced connections, this is performed against all active pooled internal connections that are retained.

Depending on your connection pool and configuration, this validation can be carried out at different times:

1. Before the pool returns a connection to the application.

2. When the application returns a connection to the pool.

3. During periodic checks of idle connections.

If your Connector/J deployment uses a connection pool that allows you to specify a validation query, take advantage of it, but ensure that the query starts exactly with /* ping */. This is particularly important if you are using the load-balancing or replication-aware features of Connector/J, as it will help keep alive connections which otherwise will go stale and die, causing problems later.


Chapter 8 Multi-Host Connections

Developers should know the following things about multi-host connections that are managed through Connector/J:

* Each multi-host connection is a wrapper of the underlying physical connections.

* Each of the underlying physical connections has its own session. Sessions cannot be tracked, shared, or copied, given the MySQL architecture.

* Every switch between physical connections means a switch between sessions.

* Within a transaction boundary, there are no switches between physical connections. Beyond a transaction boundary, there is no guarantee that a switch does not occur.

> Note

> If an application reuses session-scope data (for example, variables, SSPs) beyond a transaction boundary, failures are possible, as a switch between the physical connections (which is also a switch between sessions) might occur. Therefore, the application should re-prepare the session data and also restart the last transaction in case of an exception, or it should re-prepare session data for each new transaction if it does not want to deal with exception handling.

略


Chapter 9 Using the Connector/J Interceptor Classes

An interceptor is a software design pattern that provides a transparent way to extend or modify some aspect of a program
 With Connector/J, the interceptors are enabled and disabled by updating the connection string to refer to different sets of interceptor classes that you instantiate.

The connection properties that control the interceptors are explained in [Section 5.1, “Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J”]():

* `connectionLifecycleInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.ConnectionLifecycleInterceptor interface. In these kinds of interceptor classes, you might log events such as rollbacks, measure the time between transaction start and end, or count events such as calls to setAutoCommit().
  log事件，测量transaction开始结束时间，对setAutoCommit()的调用计数等

* `exceptionInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.ExceptionInterceptor interface. In these kinds of interceptor classes, you might add extra diagnostic information to exceptions that can have multiple causes or indicate a problem with server settings. Because exceptionInterceptors classes are only called when handling a SQLException thrown from Connector/J code, they can be used even in production deployments without substantial performance overhead.
  异常特殊处理

* `statementInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.StatementInterceptorV2 interface. In these kinds of interceptor classes, you might change or augment the processing done by certain kinds of statements, such as automatically checking for queried data in a memcached server, rewriting slow queries, logging information about statement execution, or route requests to remote servers.


Chapter 15 Troubleshooting Connector/J Applications

15.4: I have a servlet/application that works fine for a day, and then stops working overnight

MySQL closes connections after 8 hours of inactivity. You either need to use a connection pool that handles stale connections or use the autoReconnect parameter (see Section 5.1, “Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J”).

Example 15.1 Connector/J: Example of transaction with retry logic

        } catch (SQLException sqlEx) {

            //
            // The two SQL states that are 'retry-able' are 08S01
            // for a communications error, and 40001 for deadlock.
            //
            // Only retry if the error was due to a stale connection,
            // communications problem or deadlock
            //

            String sqlState = sqlEx.getSQLState();

            if ("08S01".equals(sqlState) || "40001".equals(sqlState)) {
                retryCount -= 1;
            } else {
                retryCount = 0;
            }


15.12: What should you do if you receive error messages similar to the following: “Communications link failure – Last packet sent to the server was X ms ago”?

Generally speaking, this error suggests that the network connection has been closed. There can be several root causes:

* Firewalls or routers may clamp down on idle connections (the MySQL client/server protocol does not ping).
* The MySQL Server may be closing idle connections that exceed the wait_timeout or interactive_timeout threshold.

Although network connections can be volatile, the following can be helpful in avoiding problems:

* Ensure connections are valid when used from the connection pool. Use a query that starts with /* ping */ to execute a lightweight ping instead of full query. Note, the syntax of the ping needs to be exactly as specified here.
* Minimize the duration a connection object is left idle while other application logic is executed.
* Explicitly validate the connection before using it if the connection has been left idle for an extended period of time.
* Ensure that wait_timeout and interactive_timeout are set sufficiently high.
* Ensure that tcpKeepalive is enabled.
* Ensure that any configurable firewall or router timeout settings allow for the maximum expected connection idle time.

> Note

> Do not expect to be able to reuse a connection without problems, if it has being lying idle for a period. If a connection is to be reused after being idle for any length of time, ensure that you explicitly test it before reusing it.

15.13: Why does Connector/J not reconnect to MySQL and re-issue the statement after a communication failure, instead of throwing an Exception, even though I use the autoReconnect connection string option?

略


Chapter 16 Known Issues and Limitations

When Connector/J retrieves timestamps for a daylight saving time (DST) switch day using the getTimeStamp() method on the result set, some of the returned values might be wrong. The errors can be avoided by using the following connection options when connecting to a database:

        useTimezone=true
        useLegacyDatetimeCode=false
        serverTimezone=UTC








http://dev.mysql.com/downloads/connector/j/



http://developer.51cto.com/art/200907/137823.htm


http://scau-fly.iteye.com/blog/1985252

http://blog.csdn.net/brilliancezhou




1. 初始化

Class.forName(“com.mysql.jdbc.Driver”);

为了保证调用前已经做好初始化工作，具体做了些什么呢？

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }
...
}

注册在DriverManager中

就是把这个Driver放在下面这个list中

private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();







