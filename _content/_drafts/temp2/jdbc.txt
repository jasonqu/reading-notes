jdbc

http://www.oracle.com/technetwork/java/overview-141217.html

The JDBC API provides a call-level API for SQL-based database access.

#### JDBC API Overview

The JDBC API makes it possible to do three things:

* Establish a connection with a database or access any tabular data source
* Send SQL statements
* Process the results

#### JDBC Architecture

Type 4: Direct-to-Database Pure Java Driver
This style of driver converts JDBC calls into the network protocol used directly by DBMSs, allowing a direct call from the client machine to the DBMS server and providing a practical solution for intranet access.

#### Key Features

* Full Access to Metadata
* No Installation
* Database Connection Identified by URL
  JDBC technology exploits the advantages of Internet-standard URLs to identify database connections. The JDBC API includes an even better way to identify and connect to a data source, using a DataSource object, that makes code even more portable and easier to maintain.
  In addition to this important advantage, DataSource objects can provide connection pooling and distributed transactions, essential for enterprise database computing. This functionality is provided transparently to the programmer.






http://dev.mysql.com/doc/connector-j/en/index.html

#### Chapter 2 Connector/J Versions

Connector/J 5.1 provides ease of development features, including auto-registration with the Driver Manager, standardized validity checks, categorized SQLExceptions, support for the JDBC-4.0 XML processing, per connection client information, NCHAR, NVARCHAR and NCLOB types.


http://dev.mysql.com/doc/connector-j/en/connector-j-examples.html

indexes 例子在后面

http://dev.mysql.com/doc/connector-j/en/connector-j-reference.html

5.1 Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J

This now allows per-host overrides of any configuration property for multi-host connections (that is, when using failover, load balancing, or replication). Limit the overrides to user, password, network timeouts and statement and metadata cache sizes; the results of other per-host overrides are not defined.

参数列表
http://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html


5.2 JDBC API Implementation Notes

* Connection

Unlike the pre-Connector/J JDBC driver (MM.MySQL), the isClosed() method does not ping the server to determine if it is available. In accordance with the JDBC specification, it only returns true if closed() has been called on the connection. If you need to determine if the connection is still valid, issue a simple query, such as SELECT 1. The driver will throw an exception if the connection is no longer valid.

* PreparedStatement

PreparedStatements are implemented by the driver, as MySQL does not have a prepared statement feature. Because of this, the driver does not implement getParameterMetaData() or getMetaData() as it would require the driver to have a complete SQL parser in the client.

* ResultSet

By default, ResultSets are completely retrieved and stored in memory. In most cases this is the most efficient way to operate, and due to the design of the MySQL network protocol is easier to implement. If you are working with ResultSets that have a large number of rows or large values, and cannot allocate heap space in your JVM for the memory required, you can tell the driver to stream the results back one row at a time.

To enable this functionality, create a Statement instance in the following manner:

```
stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY,
              java.sql.ResultSet.CONCUR_READ_ONLY);
stmt.setFetchSize(Integer.MIN_VALUE);
```

5.3 Java, JDBC and MySQL Types

The conversions that are always guaranteed to work are listed in the following table.
略

The ResultSet.getObject() method uses the type conversions between MySQL and Java types, following the JDBC specification where appropriate. The value returned by ResultSetMetaData.GetColumnClassName() is also shown below.
略

5.4 Using Character Sets and Unicode

All strings sent from the JDBC driver to the server are converted automatically from native Java Unicode form to the client character encoding,


Chapter 6 JDBC Concepts

6.1 Connecting to MySQL Using the JDBC DriverManager Interface

When you are using JDBC outside of an application server, the DriverManager class manages the establishment of connections.

DriverManager负责创建连接




6.4 Retrieving AUTO_INCREMENT Column Values through JDBC

At times, it can be tricky to use the SELECT LAST_INSERT_ID() query, as that function's value is scoped to a connection. So, if some other query happens on the same connection, the value is overwritten. On the other hand, the getGeneratedKeys() method is scoped by the Statement instance, so it can be used even if other queries happen on the same connection, but not on the same Statement instance.



Chapter 7 Connection Pooling with Connector/J

连接池

#### How Connection Pooling Works

Most applications only need a thread to have access to a JDBC connection when they are actively processing a transaction, which often takes only milliseconds to complete. When not processing a transaction, the connection sits idle. Connection pooling enables the idle connection to be used by some other thread to do useful work.
大多数应用只在处理事务时才使用一个jdbc连接，一般只需要几个毫秒，其他时间就是空闲。连接池允许该连接被其他线程使用，提高效率

简单讲，就是从pool中拿，用完，放回pool中

#### Benefits of Connection Pooling

* Reduced connection creation time. 减少连接创建时间
* Simplified programming model.
* Controlled resource usage.
  If you create a new connection every time a thread needs one, rather than using connection pooling, your application's resource usage can be wasteful and lead to unpredictable behavior under load.

Example 7.1 Connector/J: Using a connection pool with a J2EE application server

```
InitialContext ctx = new InitialContext();
DataSource ds =
          (DataSource)ctx.lookup("java:comp/env/jdbc/MySQLDB");
conn = ds.getConnection();

            /*
             * Now, use normal JDBC programming to work with
             * MySQL, making sure to close each resource when you're
             * finished with it, which permits the connection pool
             * resources to be recovered as quickly as possible
             */

            stmt = conn.createStatement();
            stmt.execute("SOME SQL QUERY");

            stmt.close();
            stmt = null;

            conn.close();
            conn = null;

```

When these objects are closed, they can be re-used; otherwise, they will be stranded, which means that the MySQL server resources they represent (such as buffers, locks, or sockets) are tied up for some time, or in the worst case can be tied up forever.

#### Sizing the Connection Pool

Many of these resources will be used whether or not the connection is actually doing any useful work! Connection pools can be tuned to maximize performance, while keeping resource utilization below the point where your application will start to fail rather than just run slower.
每个连接都有资源，只要创建，就要占用资源。如果不够，应用会失败而不是缓慢


#### Validating Connections

MySQL Connector/J can validate the connection by executing a lightweight ping against a server. In the case of load-balanced connections, this is performed against all active pooled internal connections that are retained.

Depending on your connection pool and configuration, this validation can be carried out at different times:

1. Before the pool returns a connection to the application.

2. When the application returns a connection to the pool.

3. During periodic checks of idle connections.

If your Connector/J deployment uses a connection pool that allows you to specify a validation query, take advantage of it, but ensure that the query starts exactly with /* ping */. This is particularly important if you are using the load-balancing or replication-aware features of Connector/J, as it will help keep alive connections which otherwise will go stale and die, causing problems later.


Chapter 8 Multi-Host Connections

Developers should know the following things about multi-host connections that are managed through Connector/J:

* Each multi-host connection is a wrapper of the underlying physical connections.

* Each of the underlying physical connections has its own session. Sessions cannot be tracked, shared, or copied, given the MySQL architecture.

* Every switch between physical connections means a switch between sessions.

* Within a transaction boundary, there are no switches between physical connections. Beyond a transaction boundary, there is no guarantee that a switch does not occur.

> Note

> If an application reuses session-scope data (for example, variables, SSPs) beyond a transaction boundary, failures are possible, as a switch between the physical connections (which is also a switch between sessions) might occur. Therefore, the application should re-prepare the session data and also restart the last transaction in case of an exception, or it should re-prepare session data for each new transaction if it does not want to deal with exception handling.

略


Chapter 9 Using the Connector/J Interceptor Classes

An interceptor is a software design pattern that provides a transparent way to extend or modify some aspect of a program
 With Connector/J, the interceptors are enabled and disabled by updating the connection string to refer to different sets of interceptor classes that you instantiate.

The connection properties that control the interceptors are explained in [Section 5.1, “Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J”]():

* `connectionLifecycleInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.ConnectionLifecycleInterceptor interface. In these kinds of interceptor classes, you might log events such as rollbacks, measure the time between transaction start and end, or count events such as calls to setAutoCommit().
  log事件，测量transaction开始结束时间，对setAutoCommit()的调用计数等

* `exceptionInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.ExceptionInterceptor interface. In these kinds of interceptor classes, you might add extra diagnostic information to exceptions that can have multiple causes or indicate a problem with server settings. Because exceptionInterceptors classes are only called when handling a SQLException thrown from Connector/J code, they can be used even in production deployments without substantial performance overhead.
  异常特殊处理

* `statementInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.StatementInterceptorV2 interface. In these kinds of interceptor classes, you might change or augment the processing done by certain kinds of statements, such as automatically checking for queried data in a memcached server, rewriting slow queries, logging information about statement execution, or route requests to remote servers.


Chapter 15 Troubleshooting Connector/J Applications

15.4: I have a servlet/application that works fine for a day, and then stops working overnight

MySQL closes connections after 8 hours of inactivity. You either need to use a connection pool that handles stale connections or use the autoReconnect parameter (see Section 5.1, “Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J”).

Example 15.1 Connector/J: Example of transaction with retry logic

        } catch (SQLException sqlEx) {

            //
            // The two SQL states that are 'retry-able' are 08S01
            // for a communications error, and 40001 for deadlock.
            //
            // Only retry if the error was due to a stale connection,
            // communications problem or deadlock
            //

            String sqlState = sqlEx.getSQLState();

            if ("08S01".equals(sqlState) || "40001".equals(sqlState)) {
                retryCount -= 1;
            } else {
                retryCount = 0;
            }


15.12: What should you do if you receive error messages similar to the following: “Communications link failure – Last packet sent to the server was X ms ago”?

Generally speaking, this error suggests that the network connection has been closed. There can be several root causes:

* Firewalls or routers may clamp down on idle connections (the MySQL client/server protocol does not ping).
* The MySQL Server may be closing idle connections that exceed the wait_timeout or interactive_timeout threshold.

Although network connections can be volatile, the following can be helpful in avoiding problems:

* Ensure connections are valid when used from the connection pool. Use a query that starts with /* ping */ to execute a lightweight ping instead of full query. Note, the syntax of the ping needs to be exactly as specified here.
* Minimize the duration a connection object is left idle while other application logic is executed.
* Explicitly validate the connection before using it if the connection has been left idle for an extended period of time.
* Ensure that wait_timeout and interactive_timeout are set sufficiently high.
* Ensure that tcpKeepalive is enabled.
* Ensure that any configurable firewall or router timeout settings allow for the maximum expected connection idle time.

> Note

> Do not expect to be able to reuse a connection without problems, if it has being lying idle for a period. If a connection is to be reused after being idle for any length of time, ensure that you explicitly test it before reusing it.

15.13: Why does Connector/J not reconnect to MySQL and re-issue the statement after a communication failure, instead of throwing an Exception, even though I use the autoReconnect connection string option?

略


Chapter 16 Known Issues and Limitations

When Connector/J retrieves timestamps for a daylight saving time (DST) switch day using the getTimeStamp() method on the result set, some of the returned values might be wrong. The errors can be avoided by using the following connection options when connecting to a database:

        useTimezone=true
        useLegacyDatetimeCode=false
        serverTimezone=UTC








http://dev.mysql.com/downloads/connector/j/



http://developer.51cto.com/art/200907/137823.htm


简单的使用用例

public class JDBCStudy {
    public static Connection getConnection() throws SQLException,
            java.lang.ClassNotFoundException {
        //第一步：加载MySQL的JDBC的驱动
        Class.forName("com.mysql.jdbc.Driver");

        //取得连接的url,能访问MySQL数据库的用户名,密码；studentinfo：数据库名
        String url = "jdbc:mysql://localhost:3306/studentinfo";
        String username = "root";
        String password = "admin";

        //第二步：创建与MySQL数据库的连接类的实例
        Connection con = DriverManager.getConnection(url, username, password);
        return con;
    }


    public static void main(String args[]) {
        try {
            //第三步：获取连接类实例con，用con创建Statement对象类实例 sql_statement
            Connection con = getConnection();
            Statement sql_statement = con.createStatement();

            /************ 对数据库进行相关操作 ************/
            //如果同名数据库存在，删除
            //sql_statement.executeUpdate("drop table if exists student");
            //执行了一个sql语句生成了一个名为student的表
            //sql_statement.executeUpdate("create table student (id int not null auto_increment, name varchar(20) not null default 'name', math int not null default 60, primary key (id) ); ");
            //向表中插入数据
            //sql_statement.executeUpdate("insert student values(1, 'liying', 98)");
            //sql_statement.executeUpdate("insert student values(2, 'jiangshan', 88)");
            //sql_statement.executeUpdate("insert student values(3, 'wangjiawu', 78)");
            //sql_statement.executeUpdate("insert student values(4, 'duchangfeng', 100)");
            //---以上操作不实用，但是列出来作为参考---

            //第四步：执行查询，用ResultSet类的对象，返回查询的结果
            String query = "select * from student";
            ResultSet result = sql_statement.executeQuery(query);
            /************ 对数据库进行相关操作 ************/

            System.out.println("Student表中的数据如下:");
            System.out.println("------------------------");
            System.out.println("学号" + " " + "姓名" + " " + "数据成绩 ");
            System.out.println("------------------------");

            //对获得的查询结果进行处理，对Result类的对象进行操作
            while (result.next()) {
                int number = result.getInt("id");
                String name = result.getString("name");
                String mathScore = result.getString("math");
                //取得数据库中的数据
                System.out.println(" " + number + " " + name + " " + mathScore);
            }

            //关闭连接和声明
            sql_statement.close();
            con.close();

        } catch (java.lang.ClassNotFoundException e) {
            //加载JDBC错误,所要用的驱动没有找到
            System.err.print("ClassNotFoundException");
            //其他错误
            System.err.println(e.getMessage());
        } catch (SQLException ex) {
            //显示数据库连接错误或查询错误
            System.err.println("SQLException: " + ex.getMessage());
        }
    }
}





1. 初始化

Class.forName(“com.mysql.jdbc.Driver”);

为了保证调用前已经做好初始化工作，具体做了些什么呢？

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }
...
}

注册在DriverManager中，why？因为创建连接的时候需要用的是java.sql.DriverManager这个类，而不是mysql自己的类，这样就做到了接口的统一：

Connection con = DriverManager.getConnection(url, username, password);

在DriverManager中所做的就是把这个Driver放在下面一个list中

private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();


getConnection 核心方法

1. 获取调用者线程的classloader

        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
        if (callerCL == null) {
            callerCL = Thread.currentThread().getContextClassLoader();
        }


2. 遍历注册的驱动并创建连接
        for(DriverInfo aDriver : registeredDrivers) {
            if(isDriverAllowed(aDriver.driver, callerCL)) {
                Connection con = aDriver.driver.connect(url, info);
            }
        }

3. 相当于把方法代理给driver，所以我们回过头来看看Driver，对mysql就是com.mysql.jdbc.NonRegisteringDriver，他也是com.mysql.jdbc.Driver的父类。

其中的逻辑很简单，可以简单的认为像下面这样：

    public java.sql.Connection connect(String url, Properties info) throws SQLException {
            if (StringUtils.startsWithIgnoreCase(url, LOADBALANCE_URL_PREFIX)) {
                return connectLoadBalanced(url, info);
            } else if (StringUtils.startsWithIgnoreCase(url, REPLICATION_URL_PREFIX)) {
                return connectReplicationConnection(url, info);
            } else if (!"1".equals(props.getProperty(NUM_HOSTS_PROPERTY_KEY))) {
            return connectFailover(url, info);
            } else {
                Connection newConn = com.mysql.jdbc.ConnectionImpl.getInstance(host(props), port(props), props, database(props), url);
            }
    }


> NOte

> 细说 NonRegisteringDriver
> TODO trackConnection connectLoadBalanced connectReplicationConnection connectFailover
parseURL 就是解析url的方法


连接管理。TODO

    protected static void trackConnection(Connection newConn) {

        ConnectionPhantomReference phantomRef = new ConnectionPhantomReference((ConnectionImpl) newConn, refQueue);
        connectionPhantomRefs.put(phantomRef, phantomRef);
    }

    protected static final ConcurrentHashMap<ConnectionPhantomReference, ConnectionPhantomReference> connectionPhantomRefs = new ConcurrentHashMap<ConnectionPhantomReference, ConnectionPhantomReference>();

    protected static final ReferenceQueue<ConnectionImpl> refQueue = new ReferenceQueue<ConnectionImpl>();

    static class ConnectionPhantomReference extends PhantomReference<ConnectionImpl> {
        private NetworkResources io;

        ConnectionPhantomReference(ConnectionImpl connectionImpl, ReferenceQueue<ConnectionImpl> q) {
            super(connectionImpl, q);

            try {
                this.io = connectionImpl.getIO().getNetworkResources();
            } catch (SQLException e) {
                // if we somehow got here and there's really no i/o, we deal with it later
            }
        }

        void cleanup() {
            if (this.io != null) {
                try {
                    this.io.forceClose();
                } finally {
                    this.io = null;
                }
            }
        }
    }

NetworkResources包含以下资源
class NetworkResources {
    private final Socket mysqlConnection;
    private final InputStream mysqlInput;
    private final OutputStream mysqlOutput;
    }

    只有一个强制关闭方法forceClose，就是先关闭mysqlInput，再关mysqlOutput，最后关mysqlConnection

其中trackConnection用在ConnectionImpl中用来跟踪连接




Connection解析

核心的代码就在这里，类型树见图

* ConnectionPropertiesImpl 实现了Connections and DataSources的相关配置方法，近5000行
* ConnectionImpl 实现了连接内容，5500多行

A Connection represents a session with a specific database. Within the context of a Connection, SQL statements are executed and results are returned.
A Connection's database is able to provide information describing its tables, its supported SQL grammar, its stored procedures, the capabilities of this connection, etc. This information is obtained with the getMetaData method.

一个连接表示到一个指定数据库的一个session，并提供了getMetaData方法来获取数据库的元数据信息。

* JDBC4Connection ConnectionImpl的子类，用于实现jdbc4的接口


ConnectionImpl方法解析


TODO
proxy
    private MySQLConnection proxy = null;

    private InvocationHandler realProxy = null;

统计
    private long queryTimeCount;
    private double queryTimeSum;
    private double queryTimeSumSquares;
    private double queryTimeMean;

timer
    private transient Timer cancelTimer;

    private List<Extension> connectionLifecycleInterceptors;

    private static final Constructor<?> JDBC_4_CONNECTION_CTOR;

    private static final int DEFAULT_RESULT_SET_TYPE = ResultSet.TYPE_FORWARD_ONLY;

    private static final int DEFAULT_RESULT_SET_CONCURRENCY = ResultSet.CONCUR_READ_ONLY;


使用工厂方法创建连接，分为jdbc3和jdbc4两种支持
    protected static Connection getInstance(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url)
            throws SQLException {
        if (!Util.isJdbc4()) {
            return new ConnectionImpl(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);
        }

        return (Connection) Util.handleNewInstance(JDBC_4_CONNECTION_CTOR, new Object[] { hostToConnectTo, Integer.valueOf(portToConnectTo), info,
                databaseToConnectTo, url }, null);
    }


    /** Are we in autoCommit mode? */
    private boolean autoCommit = true;

    /** A cache of SQL to parsed prepared statement parameters. */
    对每一个Connection有一个cache PerConnectionLRU
    private CacheAdapter<String, ParseInfo> cachedPreparedStatementParams;

    /**
     * Holds cached mappings to charset converters to avoid static
     * synchronization and at the same time save memory (each charset converter
     * takes approx 65K of static data).
     */
    private Map<String, Object> charsetConverterMap = new HashMap<String, Object>(CharsetMapping.getNumberOfCharsetsConfigured());

    /** ID used when profiling */
    private long connectionId;

统计字段

DatabaseMetaData
    /** Internal DBMD to use for various database-version specific features */
    private DatabaseMetaData dbmd = null;

核心
    /** The I/O abstraction interface (network conn to MySQL server */
    private transient MysqlIO io = null;

    /** The hostname we're connected to */
    private String host = null;

    /** Has this connection been closed? */
    private boolean isClosed = true;

    /** Is the server configured to use lower-case table names only? */
    private boolean lowerCaseTableNames = false;

    /** The JDBC URL we're using */
    private String myURL = null;

    /** Does this connection need to be tested? */
    private boolean needsPing = false;

    private int netBufferLength = 16384;

    private boolean noBackslashEscapes = false;

    /** A map of currently open statements */
    private Map<Statement, Statement> openStatements;

    private LRUCache parsedCallableStatementCache;

    /** Cache of ResultSet metadata */
    protected LRUCache resultSetMetadataCache;

    /** The timezone of the server */
    private TimeZone serverTimezoneTZ = null;

    private List<StatementInterceptorV2> statementInterceptors;

    /**
     * If a CharsetEncoder is required for escaping. Needed for SJIS and related
     * problems with \u00A5.
     */
    private boolean requiresEscapingEncoder;


构造函数就是初始化这些变量

核心代码是

            this.dbmd = getMetaData(false, false);
            initializeSafeStatementInterceptors();
            createNewIO(false);
            unSafeStatementInterceptors();

创建io, return a new MysqlIO instance connected to a server

    public void createNewIO(boolean isForReconnect) throws SQLException {
        synchronized (getConnectionMutex()) {
            // Synchronization Not needed for *new* connections, but defintely for connections going through fail-over, since we might get the new connection up
            // and running *enough* to start sending cached or still-open server-side prepared statements over to the backend before we get a chance to
            // re-prepare them...
            为什么sync的原因:fail-over

            Properties mergedProps = exposeAsProperties(this.props);

            if (!getHighAvailability()) {
                connectOneTryOnly(isForReconnect, mergedProps);
            } else {
                connectWithRetries(isForReconnect, mergedProps);
            }
        }
    }

isForReconnect如果是true，表示为重新连接，则在连接后要保留当前类中的一些参数和cache

connectOneTryOnly 与 connectWithRetries的区别在于，前者只进行一次连接，后者要进行多次连接并ping

connectOneTryOnly

            coreConnect(mergedProps);
            this.connectionId = this.io.getThreadId();
            this.isClosed = false;
            // Server properties might be different from previous connection, so initialize again...
            initializePropsFromServer();

coreConnect 确定protocal后，创建MysqlIO并握手
        this.io = new MysqlIO(newHost, newPort, mergedProps, getSocketFactoryClassName(), getProxy(), getSocketTimeout(),
                this.largeRowSizeThreshold.getValueAsInt());
        this.io.doHandshake(this.user, this.password, this.database);




核心代码，创建statement

PreparedStatement
首先归一化sql，检查cache中是不是有ParseInfo
如果没有，创建一个，并加入cache；然后包装并返回

    public java.sql.PreparedStatement clientPrepareStatement(String sql, int resultSetType, int resultSetConcurrency, boolean processEscapeCodesIfNeeded)
            throws SQLException {
        checkClosed();

        String nativeSql = processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;

        PreparedStatement pStmt = null;

        if (getCachePreparedStatements()) {
            PreparedStatement.ParseInfo pStmtInfo = this.cachedPreparedStatementParams.get(nativeSql);

            if (pStmtInfo == null) {
                pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getLoadBalanceSafeProxy(), nativeSql, this.database);

                this.cachedPreparedStatementParams.put(nativeSql, pStmt.getParseInfo());
            } else {
                pStmt = new com.mysql.jdbc.PreparedStatement(getLoadBalanceSafeProxy(), nativeSql, this.database, pStmtInfo);
            }
        } else {
            pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getLoadBalanceSafeProxy(), nativeSql, this.database);
        }

        pStmt.setResultSetType(resultSetType);
        pStmt.setResultSetConcurrency(resultSetConcurrency);

        return pStmt;
    }

Statement比较简单
    public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        checkClosed();

        StatementImpl stmt = new StatementImpl(getLoadBalanceSafeProxy(), this.database);
        stmt.setResultSetType(resultSetType);
        stmt.setResultSetConcurrency(resultSetConcurrency);

        return stmt;
    }

CallableStatement 有一个cache保存了编译过的CallableStatement参数
public java.sql.CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency)

核心
cStmt = parseCallableStatement(sql);
synchronized (cStmt) {
    cachedParamInfo = cStmt.paramInfo;
}
this.parsedCallableStatementCache.put(key, cachedParamInfo);


public java.sql.PreparedStatement prepareStatement(String sql) 
parameters:
sql - a SQL statement that may contain one or more '?' IN parameter placeholders
Returns:
a new PreparedStatement object containing the pre-compiled statement.

A SQL statement with or without IN parameters can be pre-compiled and stored in a PreparedStatement object. This object can then be used to efficiently execute this statement multiple times.
Note: This method is optimized for handling parametric SQL statements that benefit from precompilation if the driver supports precompilation. In this case, the statement is not sent to the database until the PreparedStatement is executed. This has no direct effect on users; however it does affect which method throws certain java.sql.SQLExceptions
MySQL does not support precompilation of statements, so they are handled by the driver.

动态sql，？作为占位符，由于服务器不支持statement的预编译，所以是由driver处理的

在一个sync块中，且先检查是不是已经关闭
        synchronized (getConnectionMutex()) {
            checkClosed();
            ...
        }

首先检查server能不能够支持useServerPreparedStmts
5.0.7之后，对增删改查和replace的sql是服务器支持的

如果支持，则使用cache：

                       pStmt = (com.mysql.jdbc.ServerPreparedStatement) this.serverSideStatementCache.remove(sql);

                        if (pStmt != null) {
                            ((com.mysql.jdbc.ServerPreparedStatement) pStmt).setClosed(false);
                            pStmt.clearParameters();
                        } else (pStmt == null) {
                                pStmt = ServerPreparedStatement.getInstance(getLoadBalanceSafeProxy(), nativeSql, this.database, resultSetType, resultSetConcurrency);
                        }

否则

                        pStmt = ServerPreparedStatement.getInstance(getLoadBalanceSafeProxy(), nativeSql, this.database, resultSetType, resultSetConcurrency);

如果就只不支持server的，则使用客户端的：
                pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, false);






commit
The method commit() makes all changes made since the previous commit/rollback permanent and releases any database locks currently held by the Connection. This method should only be used when auto-commit has been disabled.

                    execSQL(null, "commit", -1, null, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY, false, this.database, null, false);



realClose相当复杂，需要考虑回滚等情况

configureClientCharacterSet
一个设置charset的方法要300行，也是醉了
Sets up client character set for MySQL-4.1 and newer if the user This must be done before any further communication with the server!

execSQL 内部执行sql
    public ResultSetInternalMethods execSQL(StatementImpl callingStatement, String sql, int maxRows, Buffer packet, int resultSetType,
            int resultSetConcurrency, boolean streamResults, String catalog, Field[] cachedMetadata, boolean isBatch) throws SQLException {

核心
return this.io.sqlQueryDirect(callingStatement, sql, encoding, null, maxRows, resultSetType, resultSetConcurrency, streamResults, catalog, cachedMetadata);


Get this Connection's current transaction isolation mode.需要使用sql查询
public int getTransactionIsolation()

initializeDriverProperties本地配置
initializePropsFromServer server配置 200多行

返回escaped sql
public String nativeSQL(String sql)


public void resetServerState()
一般在pool中调用

public void rollback()
The method rollback() drops all changes made since the previous commit/rollback and releases any database locks currently held by the Connection.

除了本地取消所有操作之外，关键还是要执行rollback的sql代码：
execSQL(null, "rollback", -1, null, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY, false, this.database, null, false);

或"ROLLBACK TO SAVEPOINT "对public void rollback(final Savepoint savepoint)


setSavepoint()也是要执行SAVEPOINT代码的


public void setAutoCommit(final boolean autoCommitFlag)
If a connection is in auto-commit mode, than all its SQL statements will be executed and committed as individual transactions. Otherwise, its SQL statements are grouped into transactions that are terminated by either commit() or rollback(). By default, new connections are in auto- commit mode. The commit occurs when the statement completes or the next execute occurs, whichever comes first. In the case of statements returning a ResultSet, the statement completes when the last row of the ResultSet has been retrieved or the ResultSet has been closed. In advanced cases, a single statement may return multiple results as well as output parameter values. Here the commit occurs when all results and output param values have been retrieved.

必要时还要执行sql "SET autocommit=?"


setTransactionIsolation(int level) 需要执行sql




MysqlIO 与server交互的类

Constructor: Connect to the MySQL server and setup a stream connection.
核心
首先创建socket工厂
this.socketFactory = createSocketFactory();
然后用该工厂创建连接
this.mysqlConnection = this.socketFactory.connect(this.host, this.port, props);

然后就可以使用这个socket了
this.mysqlInput = new BufferedInputStream(this.mysqlConnection.getInputStream(), 16384);
this.mysqlOutput = new BufferedOutputStream(this.mysqlConnection.getOutputStream(), 16384);


socketFactory的默认实现是 com.mysql.jdbc.StandardSocketFactory

默认属性 tcpNoDelay tcpKeepAlive
核心代码
                        this.rawSocket = new Socket();
                        configureSocket(this.rawSocket, props);
                        InetSocketAddress sockAddr = new InetSocketAddress(possibleAddresses[i], this.port);
                        // bind to the local port if not using the ephemeral port
                        if (localSockAddr != null) {
                            this.rawSocket.bind(localSockAddr);
                        }
                        this.rawSocket.connect(sockAddr, getRealTimeout(connectTimeout));


protected ResultSetImpl getResultSet(StatementImpl callingStatement...)
Build a result set. Delegates to buildResultSetWithRows() to build a JDBC-version-specific ResultSet, given rows as byte data, and field information.

// Read in the column information
如果本地有元数据缓存metadataFromCache，则使用本地信息，否则开始部分的packet是column的信息

ResultSetImpl rs = buildResultSetWithRows(callingStatement, catalog, fields, rows, resultSetType, resultSetConcurrency, isBinaryEncoded);

rs = com.mysql.jdbc.ResultSetImpl.getInstance(catalog, fields, rows, this.connection, callingStatement, false);


doHandshake 360行
Initialize communications with the MySQL server


Send a query stored in a packet directly to the server.
final ResultSetInternalMethods sqlQueryDirect(StatementImpl callingStatement ...





example
stmt = conn.prepareStatement(sql);  
stmt.setInt(1, new Integer(1));     
rs = stmt.executeQuery();  


PreparedStatement继承自Statement

ServerPreparedStatement继承自PreparedStatement继承自StatementImpl

分别是2800、5000和2800行

从上向下看
A Statement object is used for executing a static SQL statement and obtaining the results produced by it. Only one ResultSet per Statement can be open at any point in time. Therefore, if the reading of one ResultSet is interleaved with the reading of another, each must have been generated by different Statements. All statement execute methods implicitly close a statement's current ResultSet if an open one exists.


一个内部类CancelTask，使用一个线程来处理超时
这个线程会执行 cancelStmt.execute("KILL QUERY " + CancelTask.this.connectionId);

private ResultSetInternalMethods createResultSetUsingServerFetch(String sql) {
    java.sql.PreparedStatement pStmt = this.connection.prepareStatement(sql, this.resultSetType, this.resultSetConcurrency);
    pStmt.execute();
    ResultSetInternalMethods rs = ((com.mysql.jdbc.StatementImpl) pStmt).getResultSetInternal();
    return rs;
}

private boolean execute(String sql, boolean returnGeneratedKeys) {
    if (useServerFetch()) {
        rs = createResultSetUsingServerFetch(sql);
    } else {
        打开canceltask
        rs = locallyScopedConn.execSQL(this, sql, this.maxRows, null, this.resultSetType, this.resultSetConcurrency, doStreaming, this.currentCatalog, cachedFields);
    }
}

public java.sql.ResultSet executeQuery(String sql) throws SQLException {
    与execute几乎相同
}

    protected void executeSimpleNonQuery(MySQLConnection c, String nonQuery) throws SQLException {
        c.execSQL(this, nonQuery, -1, null, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, false, this.currentCatalog, null, false).close();
    }
executeUpdate核心就是上面的execSQL，其中c 是  locallyScopedConn，即this.connection



然后是 PreparedStatement

A SQL Statement is pre-compiled and stored in a PreparedStatement object. This object can then be used to efficiently execute this statement multiple times.

内部类ParseInfo保存解析的信息

public boolean execute()
               throws SQLException
Some prepared statements return multiple results; the execute method handles these complex statements as well as the simpler form of statements handled by executeQuery and executeUpdate


Actually execute the prepared statement. This is here so server-side PreparedStatements can re-use most of the code from this class.
protected ResultSetInternalMethods executeInternal
核心
rs = locallyScopedConnection.execSQL(


public java.sql.ResultSet executeQuery()
核心
this.results = executeInternal(this.maxRows, sendPacket, doStreaming, true, metadataFromCache, false);


The number, types and properties of a ResultSet's columns are provided by the getMetaData method.
public java.sql.ResultSetMetaData getMetaData()
获取后会缓存在本地

设置参数，都会转换成string传输
    protected final void setInternal(int paramIndex, String val) throws SQLException {
        synchronized (checkClosed().getConnectionMutex()) {

            byte[] parameterAsBytes = null;

            if (this.charConverter != null) {
                parameterAsBytes = this.charConverter.toBytes(val);
            } else {
                parameterAsBytes = StringUtils.getBytes(val, this.charConverter, this.charEncoding, this.connection.getServerCharset(),
                        this.connection.parserKnowsUnicode(), getExceptionInterceptor());
            }

            最后转成byte
            setInternal(paramIndex, parameterAsBytes);
        }
    }

最后在设置一下类型
this.parameterTypes[i - 1 + getParameterIndexOffset()] = Types.BLOB;



ServerPreparedStatement
构造函数中有这样一句serverPrepare(sql);

MysqlIO mysql = this.connection.getIO();
Buffer prepareResultPacket = mysql.sendCommand(MysqlDefs.COM_PREPARE, sql, null, false, characterEncoding, 0);
this.serverStatementId = prepareResultPacket.readLong();
this.fieldCount = prepareResultPacket.readInt();
this.parameterCount = prepareResultPacket.readInt();
this.parameterBindings = new BindValue[this.parameterCount];

                for (int i = 0; i < this.parameterCount; i++) {
                    this.parameterBindings[i] = new BindValue();
                }

                this.connection.incrementNumberOfPrepares();

this.parameterFields[i++] = mysql.unpackField(metaDataPacket, false);
this.resultFields[i++] = mysql.unpackField(fieldPacket, false);


关闭资源
protected void realClose
                            MysqlIO mysql = this.connection.getIO();

                            Buffer packet = mysql.getSharedSendPacket();

                            packet.writeByte((byte) MysqlDefs.COM_CLOSE_STATEMENT);
                            packet.writeLong(this.serverStatementId);

                            mysql.sendCommand(MysqlDefs.COM_CLOSE_STATEMENT, null, packet, true, null, 0);



正正的执行
private com.mysql.jdbc.ResultSetInternalMethods serverExecute
Tells the server to execute this prepared statement with the current parameter bindings.
       
       
          -   Server gets the command 'COM_EXECUTE' to execute the
              previously         prepared query. If there is any param markers;
        then client will send the data in the following format:
       
        [COM_EXECUTE:1]
        [STMT_ID:4]
        [NULL_BITS:(param_count+7)/8)]
        [TYPES_SUPPLIED_BY_CLIENT(0/1):1]
        [[length]data]
        [[length]data] .. [[length]data].
       
        (Note: Except for string/binary types; all other types will not be
        supplied with length field)

executeQuery executeUpdate将使用父类的方法，而实际将调用executeInternal方法，而它将调用serverExecute













ResultSetImpl 8000行

A ResultSet provides access to a table of data generated by executing a Statement. The table rows are retrieved in sequence. Within a row its column values can be accessed in any order.
A ResultSet maintains a cursor pointing to its current row of data. Initially the cursor is positioned before the first row. The 'next' method moves the cursor to the next row.
The getXXX methods retrieve column values for the current row. You can retrieve values either using the index number of the column, or by using the name of the column. In general using the column index will be more efficient. Columns are numbered from 1.
For maximum portability, ResultSet columns within each row should be read in left-to-right order and each column should be read only once.
For the getXXX methods, the JDBC driver attempts to convert the underlying data to the specified Java type and returns a suitable Java value. See the JDBC specification for allowable mappings from SQL types to Java types with the ResultSet getXXX methods.
Column names used as input to getXXX methods are case insenstive. When performing a getXXX using a column name, if several columns have the same name, then the value of the first matching column will be returned. The column name option is designed to be used when column names are used in the SQL Query. For columns that are NOT explicitly named in the query, it is best to use column numbers. If column names were used there is no way for the programmer to guarentee that they actually refer to the intended columns.
A ResultSet is automatically closed by the Statement that generated it when that Statement is closed, re-executed, or is used to retrieve the next result from a sequence of multiple results.
The number, types and properties of a ResultSet's columns are provided by the ResultSetMetaData object returned by the getMetaData method.

所以mysql的int能够被适配为long之类的数据类型，就不足为奇了
一个getInt方法就有100多行，还调用了一个100多行的代码







http://www.java2s.com/Code/Java/Database-SQL-JDBC/Setupmysqldatasource.htm
datasource
见com.mysql.jdbc.jdbc2.optional包


实验，同一个connection的多个statement会不会并行？





























