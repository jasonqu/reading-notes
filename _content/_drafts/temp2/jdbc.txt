jdbc

http://www.oracle.com/technetwork/java/overview-141217.html

The JDBC API provides a call-level API for SQL-based database access.

#### JDBC API Overview

The JDBC API makes it possible to do three things:

* Establish a connection with a database or access any tabular data source
* Send SQL statements
* Process the results

#### JDBC Architecture

Type 4: Direct-to-Database Pure Java Driver
This style of driver converts JDBC calls into the network protocol used directly by DBMSs, allowing a direct call from the client machine to the DBMS server and providing a practical solution for intranet access.

#### Key Features

* Full Access to Metadata
* No Installation
* Database Connection Identified by URL
  JDBC technology exploits the advantages of Internet-standard URLs to identify database connections. The JDBC API includes an even better way to identify and connect to a data source, using a DataSource object, that makes code even more portable and easier to maintain.
  In addition to this important advantage, DataSource objects can provide connection pooling and distributed transactions, essential for enterprise database computing. This functionality is provided transparently to the programmer.






http://dev.mysql.com/doc/connector-j/en/index.html

#### Chapter 2 Connector/J Versions

Connector/J 5.1 provides ease of development features, including auto-registration with the Driver Manager, standardized validity checks, categorized SQLExceptions, support for the JDBC-4.0 XML processing, per connection client information, NCHAR, NVARCHAR and NCLOB types.


http://dev.mysql.com/doc/connector-j/en/connector-j-examples.html

indexes 例子在后面

http://dev.mysql.com/doc/connector-j/en/connector-j-reference.html

5.1 Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J

This now allows per-host overrides of any configuration property for multi-host connections (that is, when using failover, load balancing, or replication). Limit the overrides to user, password, network timeouts and statement and metadata cache sizes; the results of other per-host overrides are not defined.

参数列表
http://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html


5.2 JDBC API Implementation Notes

* Connection

Unlike the pre-Connector/J JDBC driver (MM.MySQL), the isClosed() method does not ping the server to determine if it is available. In accordance with the JDBC specification, it only returns true if closed() has been called on the connection. If you need to determine if the connection is still valid, issue a simple query, such as SELECT 1. The driver will throw an exception if the connection is no longer valid.

* PreparedStatement

PreparedStatements are implemented by the driver, as MySQL does not have a prepared statement feature. Because of this, the driver does not implement getParameterMetaData() or getMetaData() as it would require the driver to have a complete SQL parser in the client.

* ResultSet

By default, ResultSets are completely retrieved and stored in memory. In most cases this is the most efficient way to operate, and due to the design of the MySQL network protocol is easier to implement. If you are working with ResultSets that have a large number of rows or large values, and cannot allocate heap space in your JVM for the memory required, you can tell the driver to stream the results back one row at a time.

To enable this functionality, create a Statement instance in the following manner:

```
stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY,
              java.sql.ResultSet.CONCUR_READ_ONLY);
stmt.setFetchSize(Integer.MIN_VALUE);
```

5.3 Java, JDBC and MySQL Types

The conversions that are always guaranteed to work are listed in the following table.
略

The ResultSet.getObject() method uses the type conversions between MySQL and Java types, following the JDBC specification where appropriate. The value returned by ResultSetMetaData.GetColumnClassName() is also shown below.
略

5.4 Using Character Sets and Unicode

All strings sent from the JDBC driver to the server are converted automatically from native Java Unicode form to the client character encoding,


Chapter 6 JDBC Concepts

6.1 Connecting to MySQL Using the JDBC DriverManager Interface

When you are using JDBC outside of an application server, the DriverManager class manages the establishment of connections.

DriverManager负责创建连接




6.4 Retrieving AUTO_INCREMENT Column Values through JDBC

At times, it can be tricky to use the SELECT LAST_INSERT_ID() query, as that function's value is scoped to a connection. So, if some other query happens on the same connection, the value is overwritten. On the other hand, the getGeneratedKeys() method is scoped by the Statement instance, so it can be used even if other queries happen on the same connection, but not on the same Statement instance.



Chapter 7 Connection Pooling with Connector/J

连接池

#### How Connection Pooling Works

Most applications only need a thread to have access to a JDBC connection when they are actively processing a transaction, which often takes only milliseconds to complete. When not processing a transaction, the connection sits idle. Connection pooling enables the idle connection to be used by some other thread to do useful work.
大多数应用只在处理事务时才使用一个jdbc连接，一般只需要几个毫秒，其他时间就是空闲。连接池允许该连接被其他线程使用，提高效率

简单讲，就是从pool中拿，用完，放回pool中

#### Benefits of Connection Pooling

* Reduced connection creation time. 减少连接创建时间
* Simplified programming model.
* Controlled resource usage.
  If you create a new connection every time a thread needs one, rather than using connection pooling, your application's resource usage can be wasteful and lead to unpredictable behavior under load.

Example 7.1 Connector/J: Using a connection pool with a J2EE application server

```
InitialContext ctx = new InitialContext();
DataSource ds =
          (DataSource)ctx.lookup("java:comp/env/jdbc/MySQLDB");
conn = ds.getConnection();

            /*
             * Now, use normal JDBC programming to work with
             * MySQL, making sure to close each resource when you're
             * finished with it, which permits the connection pool
             * resources to be recovered as quickly as possible
             */

            stmt = conn.createStatement();
            stmt.execute("SOME SQL QUERY");

            stmt.close();
            stmt = null;

            conn.close();
            conn = null;

```

When these objects are closed, they can be re-used; otherwise, they will be stranded, which means that the MySQL server resources they represent (such as buffers, locks, or sockets) are tied up for some time, or in the worst case can be tied up forever.

#### Sizing the Connection Pool

Many of these resources will be used whether or not the connection is actually doing any useful work! Connection pools can be tuned to maximize performance, while keeping resource utilization below the point where your application will start to fail rather than just run slower.
每个连接都有资源，只要创建，就要占用资源。如果不够，应用会失败而不是缓慢


#### Validating Connections

MySQL Connector/J can validate the connection by executing a lightweight ping against a server. In the case of load-balanced connections, this is performed against all active pooled internal connections that are retained.

Depending on your connection pool and configuration, this validation can be carried out at different times:

1. Before the pool returns a connection to the application.

2. When the application returns a connection to the pool.

3. During periodic checks of idle connections.

If your Connector/J deployment uses a connection pool that allows you to specify a validation query, take advantage of it, but ensure that the query starts exactly with /* ping */. This is particularly important if you are using the load-balancing or replication-aware features of Connector/J, as it will help keep alive connections which otherwise will go stale and die, causing problems later.


Chapter 8 Multi-Host Connections

Developers should know the following things about multi-host connections that are managed through Connector/J:

* Each multi-host connection is a wrapper of the underlying physical connections.

* Each of the underlying physical connections has its own session. Sessions cannot be tracked, shared, or copied, given the MySQL architecture.

* Every switch between physical connections means a switch between sessions.

* Within a transaction boundary, there are no switches between physical connections. Beyond a transaction boundary, there is no guarantee that a switch does not occur.

> Note

> If an application reuses session-scope data (for example, variables, SSPs) beyond a transaction boundary, failures are possible, as a switch between the physical connections (which is also a switch between sessions) might occur. Therefore, the application should re-prepare the session data and also restart the last transaction in case of an exception, or it should re-prepare session data for each new transaction if it does not want to deal with exception handling.

略


Chapter 9 Using the Connector/J Interceptor Classes

An interceptor is a software design pattern that provides a transparent way to extend or modify some aspect of a program
 With Connector/J, the interceptors are enabled and disabled by updating the connection string to refer to different sets of interceptor classes that you instantiate.

The connection properties that control the interceptors are explained in [Section 5.1, “Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J”]():

* `connectionLifecycleInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.ConnectionLifecycleInterceptor interface. In these kinds of interceptor classes, you might log events such as rollbacks, measure the time between transaction start and end, or count events such as calls to setAutoCommit().
  log事件，测量transaction开始结束时间，对setAutoCommit()的调用计数等

* `exceptionInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.ExceptionInterceptor interface. In these kinds of interceptor classes, you might add extra diagnostic information to exceptions that can have multiple causes or indicate a problem with server settings. Because exceptionInterceptors classes are only called when handling a SQLException thrown from Connector/J code, they can be used even in production deployments without substantial performance overhead.
  异常特殊处理

* `statementInterceptors`, where you specify the fully qualified names of classes that implement the com.mysql.jdbc.StatementInterceptorV2 interface. In these kinds of interceptor classes, you might change or augment the processing done by certain kinds of statements, such as automatically checking for queried data in a memcached server, rewriting slow queries, logging information about statement execution, or route requests to remote servers.


Chapter 15 Troubleshooting Connector/J Applications

15.4: I have a servlet/application that works fine for a day, and then stops working overnight

MySQL closes connections after 8 hours of inactivity. You either need to use a connection pool that handles stale connections or use the autoReconnect parameter (see Section 5.1, “Driver/Datasource Class Names, URL Syntax and Configuration Properties for Connector/J”).

Example 15.1 Connector/J: Example of transaction with retry logic

        } catch (SQLException sqlEx) {

            //
            // The two SQL states that are 'retry-able' are 08S01
            // for a communications error, and 40001 for deadlock.
            //
            // Only retry if the error was due to a stale connection,
            // communications problem or deadlock
            //

            String sqlState = sqlEx.getSQLState();

            if ("08S01".equals(sqlState) || "40001".equals(sqlState)) {
                retryCount -= 1;
            } else {
                retryCount = 0;
            }


15.12: What should you do if you receive error messages similar to the following: “Communications link failure – Last packet sent to the server was X ms ago”?

Generally speaking, this error suggests that the network connection has been closed. There can be several root causes:

* Firewalls or routers may clamp down on idle connections (the MySQL client/server protocol does not ping).
* The MySQL Server may be closing idle connections that exceed the wait_timeout or interactive_timeout threshold.

Although network connections can be volatile, the following can be helpful in avoiding problems:

* Ensure connections are valid when used from the connection pool. Use a query that starts with /* ping */ to execute a lightweight ping instead of full query. Note, the syntax of the ping needs to be exactly as specified here.
* Minimize the duration a connection object is left idle while other application logic is executed.
* Explicitly validate the connection before using it if the connection has been left idle for an extended period of time.
* Ensure that wait_timeout and interactive_timeout are set sufficiently high.
* Ensure that tcpKeepalive is enabled.
* Ensure that any configurable firewall or router timeout settings allow for the maximum expected connection idle time.

> Note

> Do not expect to be able to reuse a connection without problems, if it has being lying idle for a period. If a connection is to be reused after being idle for any length of time, ensure that you explicitly test it before reusing it.

15.13: Why does Connector/J not reconnect to MySQL and re-issue the statement after a communication failure, instead of throwing an Exception, even though I use the autoReconnect connection string option?

略


Chapter 16 Known Issues and Limitations

When Connector/J retrieves timestamps for a daylight saving time (DST) switch day using the getTimeStamp() method on the result set, some of the returned values might be wrong. The errors can be avoided by using the following connection options when connecting to a database:

        useTimezone=true
        useLegacyDatetimeCode=false
        serverTimezone=UTC








http://dev.mysql.com/downloads/connector/j/



http://developer.51cto.com/art/200907/137823.htm


http://scau-fly.iteye.com/blog/1985252

http://blog.csdn.net/brilliancezhou




简单的使用用例

public class JDBCStudy {
    public static Connection getConnection() throws SQLException,
            java.lang.ClassNotFoundException {
        //第一步：加载MySQL的JDBC的驱动
        Class.forName("com.mysql.jdbc.Driver");

        //取得连接的url,能访问MySQL数据库的用户名,密码；studentinfo：数据库名
        String url = "jdbc:mysql://localhost:3306/studentinfo";
        String username = "root";
        String password = "admin";

        //第二步：创建与MySQL数据库的连接类的实例
        Connection con = DriverManager.getConnection(url, username, password);
        return con;
    }


    public static void main(String args[]) {
        try {
            //第三步：获取连接类实例con，用con创建Statement对象类实例 sql_statement
            Connection con = getConnection();
            Statement sql_statement = con.createStatement();

            /************ 对数据库进行相关操作 ************/
            //如果同名数据库存在，删除
            //sql_statement.executeUpdate("drop table if exists student");
            //执行了一个sql语句生成了一个名为student的表
            //sql_statement.executeUpdate("create table student (id int not null auto_increment, name varchar(20) not null default 'name', math int not null default 60, primary key (id) ); ");
            //向表中插入数据
            //sql_statement.executeUpdate("insert student values(1, 'liying', 98)");
            //sql_statement.executeUpdate("insert student values(2, 'jiangshan', 88)");
            //sql_statement.executeUpdate("insert student values(3, 'wangjiawu', 78)");
            //sql_statement.executeUpdate("insert student values(4, 'duchangfeng', 100)");
            //---以上操作不实用，但是列出来作为参考---

            //第四步：执行查询，用ResultSet类的对象，返回查询的结果
            String query = "select * from student";
            ResultSet result = sql_statement.executeQuery(query);
            /************ 对数据库进行相关操作 ************/

            System.out.println("Student表中的数据如下:");
            System.out.println("------------------------");
            System.out.println("学号" + " " + "姓名" + " " + "数据成绩 ");
            System.out.println("------------------------");

            //对获得的查询结果进行处理，对Result类的对象进行操作
            while (result.next()) {
                int number = result.getInt("id");
                String name = result.getString("name");
                String mathScore = result.getString("math");
                //取得数据库中的数据
                System.out.println(" " + number + " " + name + " " + mathScore);
            }

            //关闭连接和声明
            sql_statement.close();
            con.close();

        } catch (java.lang.ClassNotFoundException e) {
            //加载JDBC错误,所要用的驱动没有找到
            System.err.print("ClassNotFoundException");
            //其他错误
            System.err.println(e.getMessage());
        } catch (SQLException ex) {
            //显示数据库连接错误或查询错误
            System.err.println("SQLException: " + ex.getMessage());
        }
    }
}





1. 初始化

Class.forName(“com.mysql.jdbc.Driver”);

为了保证调用前已经做好初始化工作，具体做了些什么呢？

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }
...
}

注册在DriverManager中，why？因为创建连接的时候需要用的是java.sql.DriverManager这个类，而不是mysql自己的类，这样就做到了接口的统一：

Connection con = DriverManager.getConnection(url, username, password);

在DriverManager中所做的就是把这个Driver放在下面一个list中

private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();


getConnection 核心方法

1. 获取调用者线程的classloader

        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
        if (callerCL == null) {
            callerCL = Thread.currentThread().getContextClassLoader();
        }


2. 遍历注册的驱动并创建连接
        for(DriverInfo aDriver : registeredDrivers) {
            if(isDriverAllowed(aDriver.driver, callerCL)) {
                Connection con = aDriver.driver.connect(url, info);
            }
        }

3. 相当于把方法代理给driver，所以我们回过头来看看Driver，对mysql就是com.mysql.jdbc.NonRegisteringDriver，他也是com.mysql.jdbc.Driver的父类。

其中的逻辑很简单，可以简单的认为像下面这样：

    public java.sql.Connection connect(String url, Properties info) throws SQLException {
            if (StringUtils.startsWithIgnoreCase(url, LOADBALANCE_URL_PREFIX)) {
                return connectLoadBalanced(url, info);
            } else if (StringUtils.startsWithIgnoreCase(url, REPLICATION_URL_PREFIX)) {
                return connectReplicationConnection(url, info);
            } else if (!"1".equals(props.getProperty(NUM_HOSTS_PROPERTY_KEY))) {
            return connectFailover(url, info);
            } else {
                Connection newConn = com.mysql.jdbc.ConnectionImpl.getInstance(host(props), port(props), props, database(props), url);
            }
    }


> NOte

> 细说 NonRegisteringDriver
> TODO trackConnection connectLoadBalanced connectReplicationConnection connectFailover
parseURL 就是解析url的方法


连接管理。TODO

    protected static void trackConnection(Connection newConn) {

        ConnectionPhantomReference phantomRef = new ConnectionPhantomReference((ConnectionImpl) newConn, refQueue);
        connectionPhantomRefs.put(phantomRef, phantomRef);
    }

    protected static final ConcurrentHashMap<ConnectionPhantomReference, ConnectionPhantomReference> connectionPhantomRefs = new ConcurrentHashMap<ConnectionPhantomReference, ConnectionPhantomReference>();

    protected static final ReferenceQueue<ConnectionImpl> refQueue = new ReferenceQueue<ConnectionImpl>();

    static class ConnectionPhantomReference extends PhantomReference<ConnectionImpl> {
        private NetworkResources io;

        ConnectionPhantomReference(ConnectionImpl connectionImpl, ReferenceQueue<ConnectionImpl> q) {
            super(connectionImpl, q);

            try {
                this.io = connectionImpl.getIO().getNetworkResources();
            } catch (SQLException e) {
                // if we somehow got here and there's really no i/o, we deal with it later
            }
        }

        void cleanup() {
            if (this.io != null) {
                try {
                    this.io.forceClose();
                } finally {
                    this.io = null;
                }
            }
        }
    }

NetworkResources包含以下资源
class NetworkResources {
    private final Socket mysqlConnection;
    private final InputStream mysqlInput;
    private final OutputStream mysqlOutput;
    }

    只有一个强制关闭方法forceClose，就是先关闭mysqlInput，再关mysqlOutput，最后关mysqlConnection

其中trackConnection用在ConnectionImpl中用来跟踪连接




Connection解析

核心的代码就在这里，类型树见图

* ConnectionPropertiesImpl 实现了Connections and DataSources的相关配置方法，近5000行
* ConnectionImpl 实现了连接内容，5500多行

A Connection represents a session with a specific database. Within the context of a Connection, SQL statements are executed and results are returned.
A Connection's database is able to provide information describing its tables, its supported SQL grammar, its stored procedures, the capabilities of this connection, etc. This information is obtained with the getMetaData method.

一个连接表示到一个指定数据库的一个session，并提供了getMetaData方法来获取数据库的元数据信息。

* JDBC4Connection ConnectionImpl的子类，用于实现jdbc4的接口


ConnectionImpl方法解析


TODO
proxy
    private MySQLConnection proxy = null;

    private InvocationHandler realProxy = null;

统计
    private long queryTimeCount;
    private double queryTimeSum;
    private double queryTimeSumSquares;
    private double queryTimeMean;

timer
    private transient Timer cancelTimer;

    private List<Extension> connectionLifecycleInterceptors;

    private static final Constructor<?> JDBC_4_CONNECTION_CTOR;

    private static final int DEFAULT_RESULT_SET_TYPE = ResultSet.TYPE_FORWARD_ONLY;

    private static final int DEFAULT_RESULT_SET_CONCURRENCY = ResultSet.CONCUR_READ_ONLY;


使用工厂方法创建连接，分为jdbc3和jdbc4两种支持
    protected static Connection getInstance(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url)
            throws SQLException {
        if (!Util.isJdbc4()) {
            return new ConnectionImpl(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);
        }

        return (Connection) Util.handleNewInstance(JDBC_4_CONNECTION_CTOR, new Object[] { hostToConnectTo, Integer.valueOf(portToConnectTo), info,
                databaseToConnectTo, url }, null);
    }


    /** Are we in autoCommit mode? */
    private boolean autoCommit = true;

    /** A cache of SQL to parsed prepared statement parameters. */
    对每一个Connection有一个cache PerConnectionLRU
    private CacheAdapter<String, ParseInfo> cachedPreparedStatementParams;

    /**
     * Holds cached mappings to charset converters to avoid static
     * synchronization and at the same time save memory (each charset converter
     * takes approx 65K of static data).
     */
    private Map<String, Object> charsetConverterMap = new HashMap<String, Object>(CharsetMapping.getNumberOfCharsetsConfigured());

    /** ID used when profiling */
    private long connectionId;

统计字段

DatabaseMetaData
    /** Internal DBMD to use for various database-version specific features */
    private DatabaseMetaData dbmd = null;

核心
    /** The I/O abstraction interface (network conn to MySQL server */
    private transient MysqlIO io = null;

    /** The hostname we're connected to */
    private String host = null;

    /** Has this connection been closed? */
    private boolean isClosed = true;

    /** Is the server configured to use lower-case table names only? */
    private boolean lowerCaseTableNames = false;

    /** The JDBC URL we're using */
    private String myURL = null;

    /** Does this connection need to be tested? */
    private boolean needsPing = false;

    private int netBufferLength = 16384;

    private boolean noBackslashEscapes = false;

    /** A map of currently open statements */
    private Map<Statement, Statement> openStatements;

    private LRUCache parsedCallableStatementCache;

    /** Cache of ResultSet metadata */
    protected LRUCache resultSetMetadataCache;

    /** The timezone of the server */
    private TimeZone serverTimezoneTZ = null;

    private List<StatementInterceptorV2> statementInterceptors;

    /**
     * If a CharsetEncoder is required for escaping. Needed for SJIS and related
     * problems with \u00A5.
     */
    private boolean requiresEscapingEncoder;


构造函数就是初始化这些变量

核心代码是

            this.dbmd = getMetaData(false, false);
            initializeSafeStatementInterceptors();
            createNewIO(false);
            unSafeStatementInterceptors();

创建io, return a new MysqlIO instance connected to a server

    public void createNewIO(boolean isForReconnect) throws SQLException {
        synchronized (getConnectionMutex()) {
            // Synchronization Not needed for *new* connections, but defintely for connections going through fail-over, since we might get the new connection up
            // and running *enough* to start sending cached or still-open server-side prepared statements over to the backend before we get a chance to
            // re-prepare them...
            为什么sync的原因:fail-over

            Properties mergedProps = exposeAsProperties(this.props);

            if (!getHighAvailability()) {
                connectOneTryOnly(isForReconnect, mergedProps);
            } else {
                connectWithRetries(isForReconnect, mergedProps);
            }
        }
    }

isForReconnect如果是true，表示为重新连接，则在连接后要保留当前类中的一些参数和cache

connectOneTryOnly 与 connectWithRetries的区别在于，前者只进行一次连接，后者要进行多次连接并ping

connectOneTryOnly

            coreConnect(mergedProps);
            this.connectionId = this.io.getThreadId();
            this.isClosed = false;
            // Server properties might be different from previous connection, so initialize again...
            initializePropsFromServer();

coreConnect 确定protocal后，创建MysqlIO并握手
        this.io = new MysqlIO(newHost, newPort, mergedProps, getSocketFactoryClassName(), getProxy(), getSocketTimeout(),
                this.largeRowSizeThreshold.getValueAsInt());
        this.io.doHandshake(this.user, this.password, this.database);




核心代码，创建statement

PreparedStatement
首先归一化sql，检查cache中是不是有ParseInfo
如果没有，创建一个，并加入cache；然后包装并返回

    public java.sql.PreparedStatement clientPrepareStatement(String sql, int resultSetType, int resultSetConcurrency, boolean processEscapeCodesIfNeeded)
            throws SQLException {
        checkClosed();

        String nativeSql = processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;

        PreparedStatement pStmt = null;

        if (getCachePreparedStatements()) {
            PreparedStatement.ParseInfo pStmtInfo = this.cachedPreparedStatementParams.get(nativeSql);

            if (pStmtInfo == null) {
                pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getLoadBalanceSafeProxy(), nativeSql, this.database);

                this.cachedPreparedStatementParams.put(nativeSql, pStmt.getParseInfo());
            } else {
                pStmt = new com.mysql.jdbc.PreparedStatement(getLoadBalanceSafeProxy(), nativeSql, this.database, pStmtInfo);
            }
        } else {
            pStmt = com.mysql.jdbc.PreparedStatement.getInstance(getLoadBalanceSafeProxy(), nativeSql, this.database);
        }

        pStmt.setResultSetType(resultSetType);
        pStmt.setResultSetConcurrency(resultSetConcurrency);

        return pStmt;
    }

Statement比较简单
    public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        checkClosed();

        StatementImpl stmt = new StatementImpl(getLoadBalanceSafeProxy(), this.database);
        stmt.setResultSetType(resultSetType);
        stmt.setResultSetConcurrency(resultSetConcurrency);

        return stmt;
    }



commit
The method commit() makes all changes made since the previous commit/rollback permanent and releases any database locks currently held by the Connection. This method should only be used when auto-commit has been disabled.

                    execSQL(null, "commit", -1, null, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY, false, this.database, null, false);


configureClientCharacterSet
一个设置charset的方法要300行，也是醉了
Sets up client character set for MySQL-4.1 and newer if the user This must be done before any further communication with the server!































































